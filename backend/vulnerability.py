"""Vulnerability analyzer for V16 beacons.

Identifies beacons in potentially dangerous situations:
- Isolated locations (far from population centers) - NOW WITH REAL DATA
- Long exposure time (no resolution)
- Nighttime hours
- Secondary/local roads
"""
from datetime import datetime, timezone
from typing import Optional
from dataclasses import dataclass

from geospatial import calculate_isolation_score_sync

# Vulnerability weights
WEIGHT_ISOLATION = 0.40
WEIGHT_EXPOSURE = 0.30
WEIGHT_NIGHTTIME = 0.20
WEIGHT_ROAD_TYPE = 0.10

# Thresholds
ISOLATION_THRESHOLD_KM = 10  # Distance considered "isolated"
HIGH_RISK_THRESHOLD = 60  # Score above this = high risk
NIGHT_START = 22  # 22:00
NIGHT_END = 6  # 06:00


@dataclass
class VulnerabilityScore:
    """Vulnerability assessment for a beacon."""
    beacon_id: str
    external_id: str
    total_score: float  # 0-100
    isolation_score: float
    exposure_score: float
    nighttime_score: float
    road_type_score: float
    risk_level: str  # low, medium, high, critical
    risk_factors: list[str]
    lat: float
    lng: float
    road_name: Optional[str]
    municipality: Optional[str]
    province: Optional[str]
    activation_time: Optional[datetime]
    minutes_active: int


def calculate_isolation_score(
    lat: float, 
    lng: float,
    municipality: Optional[str] = None, 
    province: Optional[str] = None
) -> float:
    """
    Calculate isolation score based on location.
    
    Uses cached Overpass API data when available.
    Falls back to heuristic if no data.
    
    Args:
        lat: Latitude of beacon
        lng: Longitude of beacon
        municipality: Municipality name (optional, for fallback)
        province: Province name (optional, for fallback)
    
    Returns:
        Score 0-100 (100 = most isolated)
    """
    # Try to get real isolation score from cache
    real_score = calculate_isolation_score_sync(lat, lng)
    
    # If we got a cached real score (not the default 50), use it
    if real_score != 50.0:
        return real_score
    
    # Fallback to heuristic if no real data available
    if not municipality:
        return 80.0  # No municipality = assume isolated
    
    return 50.0  # Default moderate isolation


def calculate_exposure_score(activation_time: Optional[datetime]) -> tuple[float, int]:
    """
    Calculate exposure score based on time since activation.
    
    Returns:
        (score 0-100, minutes_active)
    """
    if not activation_time:
        return 30.0, 0
    
    now = datetime.now(timezone.utc)
    
    # Handle timezone-naive datetimes
    if activation_time.tzinfo is None:
        activation_time = activation_time.replace(tzinfo=timezone.utc)
    
    delta = now - activation_time
    minutes = int(delta.total_seconds() / 60)
    
    # Score increases with time
    # 0-15 min: 0-25
    # 15-30 min: 25-50
    # 30-60 min: 50-75
    # >60 min: 75-100
    if minutes < 15:
        score = (minutes / 15) * 25
    elif minutes < 30:
        score = 25 + ((minutes - 15) / 15) * 25
    elif minutes < 60:
        score = 50 + ((minutes - 30) / 30) * 25
    else:
        score = min(75 + ((minutes - 60) / 60) * 25, 100)
    
    return score, minutes


def calculate_nighttime_score() -> float:
    """
    Calculate nighttime score based on current hour.
    
    Returns:
        Score 0-100 (100 = deep night)
    """
    now = datetime.now()
    hour = now.hour
    
    # Nighttime: 22:00 - 06:00
    if hour >= NIGHT_START or hour < NIGHT_END:
        # Deep night (00:00-04:00) is highest risk
        if hour >= 0 and hour < 4:
            return 100.0
        elif hour >= 4 and hour < NIGHT_END:
            return 70.0
        else:  # 22:00-23:59
            return 60.0
    
    # Evening (18:00-22:00)
    if hour >= 18:
        return 30.0
    
    # Daytime
    return 0.0


def calculate_road_type_score(road_type: Optional[str]) -> float:
    """
    Calculate road type score.
    
    Secondary/local roads have higher risk.
    
    Returns:
        Score 0-100
    """
    if not road_type:
        return 50.0
    
    road_scores = {
        'autopista': 10.0,  # Highways have better coverage
        'nacional': 30.0,
        'autonomica': 50.0,
        'provincial': 70.0,
        'local': 90.0,
    }
    
    return road_scores.get(road_type.lower(), 50.0)


def get_risk_level(score: float) -> str:
    """Convert numeric score to risk level."""
    if score >= 80:
        return 'critical'
    elif score >= 60:
        return 'high'
    elif score >= 40:
        return 'medium'
    else:
        return 'low'


def get_risk_factors(
    isolation_score: float,
    exposure_score: float,
    nighttime_score: float,
    road_type_score: float,
    minutes_active: int
) -> list[str]:
    """Generate human-readable risk factors."""
    factors = []
    
    if isolation_score >= 60:
        factors.append("Ubicación aislada")
    
    if exposure_score >= 50:
        factors.append(f"Activa {minutes_active} min sin resolución")
    
    if nighttime_score >= 60:
        factors.append("Horario nocturno")
    
    if road_type_score >= 70:
        factors.append("Carretera secundaria/local")
    
    return factors


def analyze_beacon_vulnerability(beacon: dict) -> VulnerabilityScore:
    """
    Analyze a single beacon for vulnerability.
    
    Args:
        beacon: Dict with beacon properties
        
    Returns:
        VulnerabilityScore with detailed analysis
    """
    # Extract properties
    beacon_id = str(beacon.get('id', ''))
    external_id = beacon.get('external_id', '')
    lat = beacon.get('lat', 0)
    lng = beacon.get('lng', 0)
    road_name = beacon.get('road_name')
    road_type = beacon.get('road_type')
    municipality = beacon.get('municipality')
    province = beacon.get('province')
    activation_time = beacon.get('activation_time')
    
    # Calculate individual scores (using real geospatial data when available)
    isolation_score = calculate_isolation_score(lat, lng, municipality, province)
    exposure_score, minutes_active = calculate_exposure_score(activation_time)
    nighttime_score = calculate_nighttime_score()
    road_type_score = calculate_road_type_score(road_type)
    
    # Calculate weighted total
    total_score = (
        isolation_score * WEIGHT_ISOLATION +
        exposure_score * WEIGHT_EXPOSURE +
        nighttime_score * WEIGHT_NIGHTTIME +
        road_type_score * WEIGHT_ROAD_TYPE
    )
    
    risk_level = get_risk_level(total_score)
    risk_factors = get_risk_factors(
        isolation_score, exposure_score, nighttime_score, 
        road_type_score, minutes_active
    )
    
    return VulnerabilityScore(
        beacon_id=beacon_id,
        external_id=external_id,
        total_score=round(total_score, 1),
        isolation_score=round(isolation_score, 1),
        exposure_score=round(exposure_score, 1),
        nighttime_score=round(nighttime_score, 1),
        road_type_score=round(road_type_score, 1),
        risk_level=risk_level,
        risk_factors=risk_factors,
        lat=lat,
        lng=lng,
        road_name=road_name,
        municipality=municipality,
        province=province,
        activation_time=activation_time,
        minutes_active=minutes_active,
    )
